"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const inbound_1 = require("../message/inbound");
function createEoswsSocket(webSocketFactory, options = {}) {
    return new DefaultEoswsSocket(webSocketFactory, Object.assign({}, { autoReconnect: true }, options));
}
exports.createEoswsSocket = createEoswsSocket;
const noop = () => {
    return;
};
const DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS = 30000; // 30s
const DEFAULT_RECONNECT_DELAY_IN_MS = 5000; // 5s
class DefaultEoswsSocket {
    constructor(socketFactory, options) {
        this.isConnected = false;
        this.onSocketConnectOpenFactory = (resolve) => () => {
            this.debug("Received `onopen` (via connect) notification from socket.");
            this.isConnected = true;
            this.connectionPromise = undefined;
            if (this.keepAliveOption() === true) {
                this.registerKeepAliveHandler();
            }
            this.debug("Signaling completion of `connect` method in the outer scope.");
            resolve();
        };
        this.onSocketReconnectOpenFactory = (resolve) => () => {
            this.debug("Received `onopen` (via reconnect) notification from socket.");
            this.isConnected = true;
            this.connectionPromise = undefined;
            if (this.keepAliveOption() === true) {
                this.registerKeepAliveHandler();
            }
            this.debug("Signaling completion of `reconnect` method in the outer scope.");
            resolve(true);
            this.debug("Sending a `onReconnect` notification to client consumer.");
            this.onReconnect();
        };
        this.onSocketErrorFactory = (reject) => (event) => {
            this.debug("Received `onerror` notification from socket.");
            // The official WebSocket flow is to always send an `onclose` event after an `onerror`
            // ones, as such, we must not clean the socket at this point. We must always
            // wait and ensures the `onclose` event will be called and that clean up will
            // happen in the `onclose` handler.
            this.debug("Signaling rejection of `connect` method in the outer scope.");
            reject(event);
            this.debug("Sending an `onError` notification to client consumer.");
            this.onError(event);
        };
        this.onSocketClose = (event) => {
            this.debug("Received `onclose` notification from socket.");
            this.isConnected = false;
            this.connectionPromise = undefined;
            this.cleanSocket();
            this.debug("Sending a `onClose` notification to client consumer.");
            this.onClose(event);
            if (event.code !== 1000 && event.code !== 1005) {
                this.debug("Socket has close abnormally, trying to re-connect to socket.");
                this.reconnect();
            }
        };
        this.onSocketMessage = (event) => {
            let payload;
            try {
                payload = JSON.parse(event.data);
            }
            catch (error) {
                this.debug("Received a non JSON message, are you sure you are talking to dfuse API?");
                return;
            }
            const type = payload.type;
            if (!this.canHandleType(type)) {
                this.debug("Sending an `onInvalidMessage` notification to client consumer for type [%s].", type);
                this.onInvalidMessage(payload);
                return;
            }
            if (this.listener) {
                this.listener(payload);
            }
        };
        this.socketFactory = socketFactory;
        this.options = options;
        this.debug = debug_1.default("eosws:socket" + (options.id !== undefined ? `:${options.id}` : ""));
    }
    connect(listener) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug("About to connect to remote endpoint.");
            if (this.connectionPromise !== undefined) {
                return this.connectionPromise;
            }
            this.listener = listener;
            this.connectionPromise = new Promise((resolve, reject) => {
                this.debug("Connection promise started, creating and opening socket.");
                this.socket = this.createAnOpenSocket(this.onSocketConnectOpenFactory(resolve), this.onSocketErrorFactory(reject));
            });
            this.debug("Connection to remote endpoint initialized, returning promise to caller.");
            return this.connectionPromise;
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug("About to disconnect from remote endpoint.");
            this.listener = undefined;
            if (this.socket !== undefined && this.isConnected) {
                this.debug("Socket not closed, closing it.");
                this.socket.close();
            }
            // We must not clean up the socket at this point yet. Cleaning up the socket means
            // removing the actual event listeners. If you clean up just yet, the `onclose` event
            // will not be handled and the consumer of the library does not receive its own
            // `onClose` event. Instead, let's do the clean up once we receive the socket
            // `onclose` event.
            this.debug("Lazily disconnected, remaining clean up shall be performed when receiving `onclose` event.");
            this.isConnected = false;
            // FIXME: Shall we wait for the `onClose` to resolve a promise we set up so we effectively
            //        wait for the onclose event to happen?
        });
    }
    send(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected) {
                this.debug("Not connected, re-connecting prior sending message.");
                yield this.reconnect();
            }
            if (!this.isConnected) {
                this.debug("Socket not connected, unable to send message correctly.");
                return false;
            }
            this.debug("Sending message %O through socket.", message);
            this.socket.send(JSON.stringify(message));
            return true;
        });
    }
    createAnOpenSocket(onSocketOpen, onSocketError) {
        const socket = this.socketFactory();
        socket.onopen = onSocketOpen;
        socket.onerror = onSocketError;
        socket.onclose = this.onSocketClose;
        socket.onmessage = this.onSocketMessage;
        return socket;
    }
    canHandleType(type) {
        const actualType = (type || "").toLowerCase();
        const validTypes = Object.keys(inbound_1.InboundMessageType).map((value) => value.toLowerCase());
        // We know that in the Enum, keys are the same as the type values, so this works
        return validTypes.indexOf(actualType) > -1;
    }
    registerKeepAliveHandler() {
        const keepAliveInterval = this.options.keepAliveIntervalInMs || DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS;
        this.debug("Unregistering keep alive interval");
        this.intervalHandler = setInterval(() => {
            if (!this.isConnected || this.socket === undefined) {
                return;
            }
            this.debug("Sending keep alive pong through socket.");
            this.socket.send(JSON.stringify({ type: "pong" }));
        }, keepAliveInterval);
    }
    unregisterKeepAliveHandler() {
        if (this.intervalHandler === undefined) {
            return;
        }
        this.debug("Unregistering keep alive interval");
        clearInterval(this.intervalHandler);
        this.intervalHandler = undefined;
    }
    reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.connectionPromise) {
                try {
                    yield this.connectionPromise;
                    return true;
                }
                catch (error) {
                    this.debug("Original connection did not succeed, continuing re-connection process.");
                }
            }
            if (!this.options.autoReconnect) {
                this.debug("Not re-connecting because client consumer auto reconnect option is falsy.");
                return false;
            }
            let reconnectDelay = this.options.reconnectDelayInMs;
            if (reconnectDelay === undefined) {
                reconnectDelay = DEFAULT_RECONNECT_DELAY_IN_MS;
            }
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    this.socket = this.createAnOpenSocket(this.onSocketReconnectOpenFactory(resolve), this.onSocketErrorFactory(reject));
                }, reconnectDelay);
            });
        });
    }
    cleanSocket() {
        if (this.intervalHandler !== undefined) {
            this.unregisterKeepAliveHandler();
        }
        if (this.socket === undefined) {
            return;
        }
        this.socket.onopen = noop;
        this.socket.onclose = noop;
        this.socket.onerror = noop;
        this.socket.onmessage = noop;
        this.socket = undefined;
    }
    onInvalidMessage(message) {
        ;
        (this.options.onInvalidMessage || noop)(message);
    }
    onReconnect() {
        ;
        (this.options.onReconnect || noop)();
    }
    onClose(message) {
        ;
        (this.options.onClose || noop)(message);
    }
    onError(message) {
        ;
        (this.options.onError || noop)(message);
    }
    keepAliveOption() {
        return this.options.keepAlive === undefined ? true : this.options.keepAlive;
    }
}
//# sourceMappingURL=socket.js.map